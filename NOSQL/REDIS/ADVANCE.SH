# redis除了5种常用的基础数据结构外,还有一些高阶数据结构,有一些特定的使用场景,比如:bit(位图),hyperLogLog,bloom等

################################################### Bit ###################################################
# 很方便存储bool类型数据,当数据量大的时候节省空间,常用于记录用户一年的签到情况0,1表示,不需要使用开销较大的k-v结构
# 存储字符的时候,需要获取字符的ASCII码对应的二进制值

# set/get
setbit k 0 1
setbit k 1 1
setbit k 2 0
getbit k 0

# bitcount/pos [start end]统计和计算位置,后面是字符的范围,要是2的次方
set k v
# v的二进制一共多少个1(统计一共签到多少次)
bitcount k
# 0-0第一个字符,0-1前两个字符
bitcount k 0 0
bitcount k 0 1
# 第一个0位,1位(统计哪一天开始签到)
bitpos k 0
bitpos k 1
# 第一个字符的1位,第三个字符的0位
bitpos k 1 0 0
bitpos k 0 2 2

# 高阶bitfield操作?





################################################### HyperLogLog ###################################################
# hyperLog通常用于统计,通常情况下统计计数可以使用incrby当作计数器,但是如果需要统计去重的数量,就需要用set集合存储,比如统计页面不同的id访问数量,可以
# 使用set集合,sadd添加id,然后scard获取集合大小得出不同id数量,但是如果页面的访问量级大,就需要很大的set集合占用空间,这个时候可以考虑使用hyper结构,占
# 有空间12k,但是hyper的去重不精确,误差大概0.81%,所以适用于这种量级大,但是对结果误差不是高的统计场景.

# add/count,注意基于heyper的算法,key不能是一个字母.(pf是发明这个数据结构作者的名字缩写)
pfadd key v
pfadd key v2
pfadd key v2 v2 v2 v3 v4 v5
# 2-自动去重
pfcount key

# merge不同的key
pfadd source-key v
pfadd source-key v1
pfadd source-key v2
pfadd dest-key v1
pfadd dest-key v3
pfmerge dest-key source-key
# 3,4
pfcount source-key
pfcount dest-key





################################################### Rebloom ###################################################
# redis需要安装Rebloom插件,布隆过滤器Bloom Filter是专门用于去重,同时节省空间,但是判断存在误差,相当于一个不精确的set,它能正确判断一个元素一定不
# 存在,但是有可能不存在的它会判断存在,误判率默认是1%,具体可以通过调整error_rate(0.01)和initial_size(100),错误率越低,就需要越大的空间.比如新闻
# 广告推送给用户,但是只能推送没有浏览过的id,如果数据量大无论是关系型数据库,还是使用缓存,日积月累下都不是可行方案,这个时候可以使用bloom节省,快速判断id
# 一定不存在就可以推送给用户,偶尔会误判,一个id用户没浏览,也不会推送,这个损失误差能接受.(设置错误率,然后最好精确估计初始值,再加上一定的冗余空间)

# 布隆原理:大致结构维护了一个超大的位数组,还有几个(假设3个)无偏hash函数(无偏就是把hash值计算的很均匀,减少冲突),然后add值的时候,会通过这3个无偏hash
# 函数分别计算出3个hash值然后取模等等,最终分别得到3个数组下标插入1,当下一个值来的时候,仍然计算hash得出对应的三个数组下标,如果有一个为0就一定不存在,但
# 是如果都为1也有一定可能不存在,因为即使使用了无偏hash还是有一定几率计算出不同的key得到相同的下标,这也是误差的原因,所以设置好空间初始容量很重要,不要让
# 实际元素大于初始容量,如果大于就需要重建bloom过滤器,把所有的历史数据转移,同时error_rate也不会因为超过容量就错误率暴增.此外bloom空间的节约体现在存
# 储结构上,正常的set集合需要存储数据的内容,以及指针等内容,而bloom只需要存储元素的指纹信息??所以节约空间.

# add/exists
bf.add k v
# 0不存在,1存在
bf.exists k v

# 批量
bf.madd k v1 v2 v3 v4
# 1 1 0
bf.exists k v1 v2 v8

